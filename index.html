<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeMasto News - Keep Up With What's Happening on a Second Screen</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        word-wrap: break-word;
        font-family: Arial, Helvetica, sans-serif;
      }

      #header-section, #footer-section {
        background-color: #333;
        color: white;
        text-align: center;
        padding: 1rem;
      }

      #main-section {
        flex: 1;
        display: flex;
        flex-direction: row;
        justify-content: space-around;
        flex-wrap: wrap;
      }

      .first-column {
        display: flex;
        flex-direction: column;
        flex: 1;
        max-width: 25%;
        min-width: 300px;
      }

      .sub-section {
        padding: 1rem;
        border: 1px solid #ddd;
        word-wrap: break-word;
        flex: 1;
        align-items: flex-start;
        margin: 0.5rem;
        background-color: #f9f9f9;
        border-radius: 0.25rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      }

      #footer-section {
        text-align: center;
      }

      #mastodon-section {
        border-top: 4px solid darkgreen;
        padding: 0.5rem 0;
        padding-bottom: 1rem;
      }

      #cnn-section {
        border-top: 4px solid red;
        border-bottom: 1px solid #ccc;
        padding: 0.5rem 0;
        padding-bottom: 1rem;
      }

      #mastodon-trends-section {
        border-top: 4px solid #ccc;
        padding: 0.5rem 0;
        font-size: 18px;
      }

      .section-heading {
        font-size: 18px;
        color: darkblue;
        font-weight: bolder;
        padding-top: 0.5rem; 
        padding-bottom: 0.5rem; 
      }

      .rss-post {
        border-top: 4px solid purple;
        padding: 0.5rem 0;
        padding-bottom: 1rem;
        word-break: break-word;
        margin-bottom: 1rem;
        border-bottom: 1px solid #e0e0e0;
      }

      .rss-post h3, .mastodon-trend h3, .cnn-post h3 {
        margin: 0;
        font-size: 1.2rem;
      }

      .rss-post small, .mastodon-trend small, .cnn-post small {
        display: inline-block;
        margin-right: 1rem;
        margin-top: 0.5rem;
        color: #666;
      }
      
      .post-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
      }
      
      .post-author {
        font-weight: bold;
        color: #333;
      }
      
      .view-original {
        color: #2b90d9;
        transition: color 0.2s;
      }
      
      .view-original:hover {
        color: #1a6ca6;
      }
      
      .post-content {
        margin: 0.5rem 0;
      }
      
      .post-media {
        margin: 0.5rem 0;
        max-width: 100%;
        overflow: hidden;
        border-radius: 4px;
      }
      
      .post-media img, .post-media video {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        border: 1px solid #e0e0e0;
        display: block;
      }
      
      .media-attachment {
        display: inline-block;
        padding: 0.5rem;
        background-color: #f0f0f0;
        border-radius: 4px;
        color: #333;
        text-decoration: none;
        border: 1px solid #ddd;
      }
      
      .media-attachment:hover {
        background-color: #e0e0e0;
      }
      
      .content-text {
        margin-top: 0;
      }
      
      .loading {
        color: #666;
        padding: 1rem;
        text-align: center;
        font-style: italic;
      }
      
      .post-meta {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        font-size: 0.85rem;
      }
      
      .tag-label a {
        color: #2b90d9;
        text-decoration: none;
      }
      
      .tag-label a:hover {
        text-decoration: underline;
      }

      #date-time {
        font-size: 24px;
        color: #e8ebf0;
        background-color: #152567;
        padding: 4px 8px;
        font-family: "Andale Mono", monospace;
        border-radius: 4px;
      }
      
      /* Tag manager styles */
      #tag-manager {
        margin-bottom: 1rem;
        padding: 1rem;
        border: 1px solid #ddd;
        background-color: #f9f9f9;
        border-radius: 0.25rem;
      }

      .tag-pill {
        display: inline-block;
        background-color: #2b90d9;
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 1rem;
        margin: 0.25rem;
      }

      .remove-tag {
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        font-weight: bold;
        margin-left: 0.25rem;
      }

      .add-tag-form {
        margin-top: 0.5rem;
        display: flex;
      }

      .tag-input {
        flex: 1;
        padding: 0.5rem;
        border: 1px solid #ddd;
        border-radius: 0.25rem 0 0 0.25rem;
      }

      .tag-submit {
        padding: 0.5rem 1rem;
        background-color: #2b90d9;
        color: white;
        border: none;
        border-radius: 0 0.25rem 0.25rem 0;
        cursor: pointer;
      }
      
      /* Settings panel */
      #settings-panel {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 0.25rem;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        padding: 1rem;
        z-index: 1000;
        max-width: 400px;
        display: none;
      }
      
      #settings-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #2b90d9;
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 1001;
      }
      
      .settings-group {
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #eee;
      }
      
      .refresh-setting {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin: 0.5rem 0;
      }
      
      .refresh-setting input {
        width: 80px;
      }
      
      .mastodon-instance-input {
        width: 100%;
        padding: 0.5rem;
        margin-top: 0.5rem;
        border: 1px solid #ddd;
        border-radius: 0.25rem;
      }

   
/* Container for the entire feed section */
.feed-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

/* Counter that stays at the top */
.feed-counter {
  background-color: #f3f4f6;
  padding: 8px 12px;
  border-radius: 4px;
  margin-bottom: 12px;
  font-size: 0.9rem;
  color: #606060;
  border-left: 4px solid #2b90d9;
  position: sticky;
  top: 0;
  z-index: 10;
}

/* Scrollable container for the posts */
.posts-scroll-container {
  max-height: 600px;
  overflow-y: auto;
  padding-right: 10px;
  /* Styling for scrollbar - webkit browsers */
  scrollbar-width: thin;
  scrollbar-color: #2b90d9 #f1f1f1;
}

/* For Webkit browsers like Chrome, Safari */
.posts-scroll-container::-webkit-scrollbar {
  width: 8px;
}

.posts-scroll-container::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 4px;
}

.posts-scroll-container::-webkit-scrollbar-thumb {
  background: #2b90d9;
  border-radius: 4px;
}

.posts-scroll-container::-webkit-scrollbar-thumb:hover {
  background: #1a6ca6;
}
 
 .post-tags {
  margin-top: 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

.tag-link {
  display: inline-block;
  font-size: 0.8rem;
  color: #2b90d9;
  text-decoration: none;
  padding: 2px 6px;
  border-radius: 3px;
  background-color: #f0f0f0;
  transition: background-color 0.2s;
}

.tag-link:hover {
  background-color: #e0e0e0;
  text-decoration: none;
}

.tag-link.monitored-tag {
  background-color: #d4e9f7;
  border-left: 2px solid #2b90d9;
  font-weight: bold;
}

.tag-source {
  margin-left: 10px;
  border-left: 1px solid #ddd;
  padding-left: 10px;
}

/* Styling for trending tags table */
.trending-tags-table {
  width: 100%;
  border-collapse: collapse;
  margin: 10px 0;
  font-size: 0.95rem;
}

.trending-tags-table th {
  padding: 8px;
  text-align: left;
  border-bottom: 2px solid #ddd;
  font-weight: bold;
  color: #444;
}

.trending-tags-table td {
  padding: 8px;
  border-bottom: 1px solid #eee;
}

.trending-tag-link {
  color: #2b90d9;
  text-decoration: none;
  font-weight: bold;
}

.trending-tag-link:hover {
  text-decoration: underline;
}

.add-tag-button {
  background-color: #2b90d9;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: background-color 0.2s;
}

.add-tag-button:hover {
  background-color: #1a6ca6;
}

.monitored-badge {
  display: inline-block;
  background-color: #4caf50;
  color: white;
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 0.8rem;
}

/* Add these styles for the header */
.header-container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  width: 100%;
}

.header-left, .header-right {
  min-width: 120px;
  display: flex;
  align-items: center;
}

.header-left {
  justify-content: flex-start;
}

.header-right {
  justify-content: flex-end;
}

.header-link {
  color: #e8ebf0;
  text-decoration: none;
  padding: 6px 12px;
  border-radius: 4px;
  transition: background-color 0.2s, color 0.2s;
  font-weight: bold;
}

.header-link:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: white;
}

/* Make sure the clock stays centered */
#date-time {
  font-size: 24px;
  color: #e8ebf0;
  background-color: #152567;
  padding: 4px 8px;
  font-family: "Andale Mono", monospace;
  border-radius: 4px;
  margin: 0 auto;
}

/* Add a counter at the top of the feed */
.feed-counter {
  background-color: #f3f4f6;
  padding: 8px 12px;
  border-radius: 4px;
  margin-bottom: 12px;
  font-size: 0.9rem;
  color: #606060;
  border-left: 4px solid #2b90d9;
}
      
      /* Responsive adjustments */
      @media (max-width: 1200px) {
        #main-section {
          flex-direction: column;
        }
        
        .first-column {
          max-width: 100%;
        }
        
        .sub-section {
          margin: 0.5rem 0;
        }
      }
    </style>
  </head>
  <body>
   <header id="header-section">
  <div class="header-container">
    <div class="header-left">
      <a href="https://mastogizmos.com/" class="header-link">Back to MastoGizmos</a>
    </div>
    <div id="date-time"></div>
    <div class="header-right">
      <a href="https://www.calishat.com/" target="_blank" class="header-link">(This is a Calishat Jam)</a>
    </div>
  </div>
</header>
    
    <main id="main-section">
      <div class="first-column">
        <div class="sub-section" id="section1">
          <div class="section-heading">Latest from the NYT</div>
          <div id="cnn-section"></div>
          
          <div class="section-heading">Trending Hashtags on <span id="trending-tags-instance">Mastodon.Social</span></div> 
          <div id="mastodon-trends-section"></div>
        </div>
        <div class="sub-section" id="section2"></div>
      </div>
      
      <div class="sub-section" id="section3">
        <div class="section-heading">Trending Links On <span id="trending-links-instance">Mastodon.Social</span></div>
        <div id="mastodon-section"></div>
      </div>
      
      <div class="sub-section" id="section4">
        <div class="section-heading">Mastodon Tag Monitors</div>
        <div id="tag-manager">
          <h3>Choose Mastodon Hashtags to Monitor</h3>
          <div id="current-tags"></div>
          <form id="add-tag-form" class="add-tag-form">
            <input type="text" id="new-tag" class="tag-input" placeholder="Enter a tag (without #)">
            <button type="submit" class="tag-submit">Add Tag</button>
          </form>
        </div>
        <div id="rss-section"></div>
      </div>
    </main>
    
    <footer id="footer-section">
      <p>VibeMasto News - Stay updated with the latest trends</p>
    </footer>
    
    <!-- Settings Panel -->
    <button id="settings-toggle">⚙️</button>
    <div id="settings-panel">
      <h3>Settings</h3>
      
      <div class="settings-group">
        <h4>Refresh Intervals (minutes)</h4>
        <div class="refresh-setting">
          <label for="news-refresh">News Feed:</label>
          <input type="number" id="news-refresh" min="1" max="60" value="5">
        </div>
        <div class="refresh-setting">
          <label for="trending-links-refresh">Trending Links:</label>
          <input type="number" id="trending-links-refresh" min="1" max="60" value="5">
        </div>
        <div class="refresh-setting">
          <label for="trending-tags-refresh">Trending Tags:</label>
          <input type="number" id="trending-tags-refresh" min="1" max="60" value="10">
        </div>
        <div class="refresh-setting">
          <label for="tag-monitors-refresh">Tag Monitors:</label>
          <input type="number" id="tag-monitors-refresh" min="1" max="60" value="5">
        </div>
        <div class="refresh-setting">
  <label for="max-posts">Maximum posts to display:</label>
  <input type="number" id="max-posts" min="5" max="100" value="20">
</div>
<div class="settings-group">
  <h4>Time Zone Settings</h4>
  <p>Select your preferred time zone for the clock:</p>
  <select id="timezone-select" class="mastodon-instance-input">
    <option value="local">Local System Time</option>
    <option value="America/New_York">Eastern Time (ET)</option>
    <option value="America/Chicago">Central Time (CT)</option>
    <option value="America/Denver">Mountain Time (MT)</option>
    <option value="America/Los_Angeles">Pacific Time (PT)</option>
    <option value="America/Anchorage">Alaska Time (AKT)</option>
    <option value="Pacific/Honolulu">Hawaii Time (HT)</option>
    <option value="Europe/London">London (GMT/BST)</option>
    <option value="Europe/Paris">Paris/Berlin (CET)</option>
    <option value="Europe/Moscow">Moscow (MSK)</option>
    <option value="Asia/Tokyo">Tokyo (JST)</option>
    <option value="Asia/Shanghai">China (CST)</option>
    <option value="Australia/Sydney">Sydney (AEST)</option>
  </select>
</div>
      </div>
      
      <div class="settings-group">
        <h4>Mastodon Instance</h4>
        <p>Change the Mastodon instance for trending data:</p>
        <input type="text" id="mastodon-instance" class="mastodon-instance-input" value="mastodon.social">
        <button id="save-instance" class="tag-submit" style="margin-top: 0.5rem; width: 100%;">Save Instance</button>
      </div>
      
      <div class="settings-group">
        <h4>News Source</h4>
        <p>Change the news source RSS feed:</p>
        <input type="text" id="news-source" class="mastodon-instance-input" value="https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml">
        <button id="save-news-source" class="tag-submit" style="margin-top: 0.5rem; width: 100%;">Save News Source</button>
      </div>
    </div>

    <script>
      // Utility functions
      const $ = selector => document.querySelector(selector);
      const $$ = selector => document.querySelectorAll(selector);
      
      // CORS proxy for RSS feeds
      const corsProxy = 'https://corsproxy.io/?url=';

      // --------- Settings and Configuration ---------
      
      // Save and load functions for settings
      function saveSettings(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
      }
      
      function loadSettings(key, defaultValue) {
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : defaultValue;
      }
      
      // Initialize settings
    let settings = {
  refreshIntervals: loadSettings('refreshIntervals', {
    news: 5,
    trendingLinks: 5,
    trendingTags: 10,
    tagMonitors: 5
  }),
  mastodonInstance: loadSettings('mastodonInstance', 'mastodon.social'),
  newsSource: loadSettings('newsSource', 'https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml'),
  maxPosts: loadSettings('maxPosts', 20),
  timezone: loadSettings('timezone', 'local') // Add this line
};
      
      // Update UI with saved settings
   function updateSettingsUI() {
  $('#news-refresh').value = settings.refreshIntervals.news;
  $('#trending-links-refresh').value = settings.refreshIntervals.trendingLinks;
  $('#trending-tags-refresh').value = settings.refreshIntervals.trendingTags;
  $('#tag-monitors-refresh').value = settings.refreshIntervals.tagMonitors;
  $('#max-posts').value = settings.maxPosts;
  $('#mastodon-instance').value = settings.mastodonInstance;
  $('#news-source').value = settings.newsSource;
  $('#timezone-select').value = settings.timezone;
  
  // Update instance names in headings
  $('#trending-tags-instance').textContent = settings.mastodonInstance;
  $('#trending-links-instance').textContent = settings.mastodonInstance;
}
      
      // Save settings when inputs change
     $('#settings-panel').addEventListener('change', e => {
  if (e.target.id === 'news-refresh') {
    settings.refreshIntervals.news = parseInt(e.target.value);
  } else if (e.target.id === 'trending-links-refresh') {
    settings.refreshIntervals.trendingLinks = parseInt(e.target.value);
  } else if (e.target.id === 'trending-tags-refresh') {
    settings.refreshIntervals.trendingTags = parseInt(e.target.value);
  } else if (e.target.id === 'tag-monitors-refresh') {
    settings.refreshIntervals.tagMonitors = parseInt(e.target.value);
  } else if (e.target.id === 'max-posts') {
    settings.maxPosts = parseInt(e.target.value);
    saveSettings('maxPosts', settings.maxPosts);
    fetchRSSFeeds(); // Refresh with new limit
  } else if (e.target.id === 'timezone-select') {  // Add this section
    settings.timezone = e.target.value;
    saveSettings('timezone', settings.timezone);
  }
  
  saveSettings('refreshIntervals', settings.refreshIntervals);
  resetIntervals();
});
      
      // Save Mastodon instance
      $('#save-instance').addEventListener('click', () => {
        settings.mastodonInstance = $('#mastodon-instance').value.trim();
        saveSettings('mastodonInstance', settings.mastodonInstance);
        updateSettingsUI();
        
        // Refresh data with new instance
        fetchMastodonTags();
        fetchMastodonTrends();
      });
      
      // Save news source
      $('#save-news-source').addEventListener('click', () => {
        settings.newsSource = $('#news-source').value.trim();
        saveSettings('newsSource', settings.newsSource);
        fetchNewsFeed();
      });
      
      // Toggle settings panel
      $('#settings-toggle').addEventListener('click', () => {
        const panel = $('#settings-panel');
        if (panel.style.display === 'none' || !panel.style.display) {
          panel.style.display = 'block';
        } else {
          panel.style.display = 'none';
        }
      });
      
      function notifyTagChange() {
  // Dispatch a custom event that components can listen for
  const event = new CustomEvent('tagListChanged', {
    detail: { tags: userTags }
  });
  document.dispatchEvent(event);
}
      
      // Initialize tags from localStorage or use defaults
      function getStoredTags() {
    
        const storedTags = localStorage.getItem('mastodonTags');
        return storedTags ? JSON.parse(storedTags) : ['RSS', 'Mastodon', 'Fediverse'];
      }

      // Convert tags to RSS feed URLs
      function tagsToFeeds(tags) {
        return tags.map(tag => `https://${settings.mastodonInstance}/tags/${tag}.rss`);
      }

      // Initial setup
      let userTags = getStoredTags();
      let rssFeeds = tagsToFeeds(userTags);

      // Function to add a new tag
     function addTag(tag) {
  // Normalize the tag (remove # if present, trim whitespace)
  tag = tag.replace(/^#/, '').trim().toLowerCase();
  
  // Don't add if empty or already exists
  if (!tag || userTags.includes(tag)) return false;
  
  userTags.push(tag);
  localStorage.setItem('mastodonTags', JSON.stringify(userTags));
  rssFeeds = tagsToFeeds(userTags);
  
  // Notify about the tag change
  notifyTagChange();
  
  return true;
}

      // Function to remove a tag
      function removeTag(tag) {
  const index = userTags.indexOf(tag);
  if (index > -1) {
    userTags.splice(index, 1);
    localStorage.setItem('mastodonTags', JSON.stringify(userTags));
    rssFeeds = tagsToFeeds(userTags);
    
    // Notify about the tag change
    notifyTagChange();
    
    return true;
  }
  return false;
}
      
      // Function to display current tags with remove buttons
      function displayCurrentTags() {
        const tagsContainer = $('#current-tags');
        tagsContainer.innerHTML = '';
        
        userTags.forEach(tag => {
          const tagElement = document.createElement('span');
          tagElement.className = 'tag-pill';
          tagElement.innerHTML = `#${tag} <button class="remove-tag" data-tag="${tag}">×</button>`;
          tagsContainer.appendChild(tagElement);
        });
        
        // Add event listeners to remove buttons
        $$('.remove-tag').forEach(button => {
          button.addEventListener('click', function() {
            const tag = this.getAttribute('data-tag');
            if (removeTag(tag)) {
              displayCurrentTags();
              // Refresh feeds when a tag is removed
              fetchRSSFeeds();
            }
          });
        });
      }

      // Set up form submission for adding tags
      $('#add-tag-form').addEventListener('submit', function(e) {
        e.preventDefault();
        const input = $('#new-tag');
        const tag = input.value;
        
        if (addTag(tag)) {
          input.value = ''; // Clear the input
          displayCurrentTags();
          // Refresh feeds when a new tag is added
          fetchRSSFeeds();
        }
      });
      
      // --------- Fetch functions ---------
      
      // Fetch trending links from Mastodon
      async function fetchMastodonTrends() {
        try {
          const response = await fetch(`https://${settings.mastodonInstance}/api/v1/trends/links`);
          if (!response.ok) throw new Error(`HTTP error ${response.status}`);
          
          const trends = await response.json();
          
          // Sort by published date in descending order
          trends.sort((a, b) => new Date(b.published_at) - new Date(a.published_at));
          
          // Pick top 5 trending links
          const topTrends = trends.slice(0, 5);
          
          // Display the posts
          displayMastodonTrends(topTrends);
        } catch (error) {
          console.error('Error fetching Mastodon trends:', error);
          $('#mastodon-section').innerHTML = `<div class="error">Error loading trending links: ${error.message}</div>`;
        }
      }

      // Display Mastodon trending links
      function displayMastodonTrends(trends) { 
        const mastodonSection = $('#mastodon-section'); 
        mastodonSection.innerHTML = '';
        
        if (trends.length === 0) {
          mastodonSection.innerHTML = '<p>No trending links available</p>';
          return;
        }

        trends.forEach((trend) => {
          const trendDiv = document.createElement('div');
          trendDiv.className = 'mastodon-trend';

          trendDiv.innerHTML = `
            <h3><a href="${trend.url}" target="_blank">${trend.title}</a></h3>
            <p>${trend.description}</p>
            <small>Published at: ${new Date(trend.published_at).toLocaleString()}</small>
            <small>Author: <a href="${trend.author_url}" target="_blank">${trend.author_name}</a></small>
          `;

          mastodonSection.appendChild(trendDiv);
        });
      }

      // Fetch news feed  
      async function fetchNewsFeed() {
        const feedUrl = settings.newsSource;
        const corsUrl = `${corsProxy}${encodeURIComponent(feedUrl)}`;
        const newsPosts = [];

        try {
          const response = await fetch(corsUrl);

          if (response.ok) {
            let text = await response.text();
            text = text.replace(/xmlns[^=]*="[^"]*"/g, ''); // Remove namespace

            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(text, 'text/xml');

            if (xmlDoc.documentElement.nodeName === 'parsererror') {
              throw new Error('Error parsing XML: ' + xmlDoc.documentElement.textContent);
            }

            const items = xmlDoc.querySelectorAll('item');
            items.forEach((item) => {
              const title = item.querySelector('title')?.textContent || "";
              const pubDate = new Date(item.querySelector('pubDate')?.textContent || "");
              const description = item.querySelector('description')?.textContent || "";
              const link = item.querySelector('link')?.textContent || "";

              newsPosts.push({ title, pubDate, description, link });
            });

            // Sort by date in descending order
            newsPosts.sort((a, b) => b.pubDate - a.pubDate);

            // Pick top 3 posts
            const topPosts = newsPosts.slice(0, 3);

            // Display the posts
            displayNewsPosts(topPosts);
          } else {
            throw new Error(`Failed to fetch ${feedUrl}. Status: ${response.status}`);
          }
        } catch (error) {
          console.error(`An error occurred while fetching ${feedUrl}:`, error);
          $('#cnn-section').innerHTML = `<div class="error">Error loading news feed: ${error.message}</div>`;
        }
      }

      // Display news posts
      function displayNewsPosts(posts) {
        const newsSection = $('#cnn-section');
        newsSection.innerHTML = '';
        
        if (posts.length === 0) {
          newsSection.innerHTML = '<p>No news posts available</p>';
          return;
        }

        posts.forEach((post) => {
          const postDiv = document.createElement('div');
          postDiv.className = 'cnn-post';

          postDiv.innerHTML = `
            <h3><a href="${post.link}" target="_blank">${post.title}</a></h3>
            <p>${post.description}</p>
            <small>${post.pubDate.toLocaleString()}</small>
          `;

          newsSection.appendChild(postDiv);
        });
      }

       
     // Fetch RSS feeds from Mastodon tags with deduplication
async function fetchRSSFeeds() {
  const allPosts = [];
  const postGuids = new Set(); // Track unique post GUIDs to prevent duplicates
  
  // Update feed URLs based on current instance
  rssFeeds = tagsToFeeds(userTags);
  
  // Show loading indicator
  const rssSection = $('#rss-section');
  rssSection.innerHTML = '<div class="loading">Loading posts from monitored tags...</div>';

  for (const feedUrl of rssFeeds) {
    const corsUrl = `${corsProxy}${encodeURIComponent(feedUrl)}`;
    
    try {
      const response = await fetch(corsUrl);

      if (response.ok) {
        let text = await response.text();

        // Remove namespace info for easier querying
        text = text.replace(/xmlns[^=]*="[^"]*"/g, '');

        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(text, 'text/xml');

        if (xmlDoc.documentElement.nodeName === 'parsererror') {
          console.error('Error parsing XML:', xmlDoc.documentElement.textContent);
          continue;
        }

        const items = xmlDoc.querySelectorAll('item');
        items.forEach((item) => {
          const title = item.querySelector('title')?.textContent || "";
          const pubDate = new Date(item.querySelector('pubDate')?.textContent || "");
          const description = item.querySelector('description')?.textContent || "";
          const link = item.querySelector('link')?.textContent || "";
          const guid = item.querySelector('guid')?.textContent || "";
          const tag = feedUrl.split('/tags/')[1].split('.rss')[0]; // Extract tag name
          
          // Skip if we've already seen this post (by GUID)
          if (postGuids.has(guid)) {
            return;
          }
          
          // Add this GUID to our tracking set
          postGuids.add(guid);
          
          // Get all categories
          const categories = Array.from(item.querySelectorAll('category')).map(cat => cat.textContent);
          
          // Try to get creator/author information
          const creator = item.querySelector('dc\\:creator, creator')?.textContent || "";
          
          // For Mastodon posts, the author can sometimes be extracted from the link
          let authorFromLink = "";
          if (link.includes('@')) {
            const linkParts = link.split('@');
            if (linkParts.length > 1) {
              const afterAt = linkParts[1];
              const slashIndex = afterAt.indexOf('/');
              if (slashIndex > 0) {
                authorFromLink = afterAt.substring(0, slashIndex);
              }
            }
          }
          
          // Get all media enclosures and content
          const mediaElements = Array.from(item.querySelectorAll('enclosure, media\\:content, content'));
          const media = mediaElements.map(el => ({
            url: el.getAttribute('url') || '',
            type: el.getAttribute('type') || '',
            width: el.getAttribute('width') || '',
            height: el.getAttribute('height') || ''
          })).filter(m => m.url);

          // Get all tags from the post content
          const allTags = [];
          // Extract hashtags from categories
          if (categories && categories.length > 0) {
            allTags.push(...categories);
          }
          
          // Also look for hashtags in the description
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = description;
          const hashtagLinks = tempDiv.querySelectorAll('a.hashtag');
          if (hashtagLinks && hashtagLinks.length > 0) {
            hashtagLinks.forEach(link => {
              const tagText = link.textContent.replace(/^#/, '').toLowerCase();
              if (tagText && !allTags.includes(tagText)) {
                allTags.push(tagText);
              }
            });
          }

          allPosts.push({ 
            title, 
            pubDate, 
            description, 
            link, 
            guid,
            tag, // The tag from which this post was found
            allTags, // All tags in the post
            categories,
            creator: creator || authorFromLink,
            media
          });
        });
      } else {
        console.warn(`Failed to fetch ${feedUrl}. Status: ${response.status}`);
      }
    } catch (error) {
      console.error(`Error fetching ${feedUrl}:`, error);
    }
  }

  // Sort all posts by date (newest first)
  allPosts.sort((a, b) => b.pubDate - a.pubDate);
  
  // Display the posts
  displayLatestPosts(allPosts);
}
 
// Display latest posts from RSS feeds
function displayLatestPosts(posts) {
  const rssSection = $('#rss-section');
  rssSection.innerHTML = '';
  
  if (posts.length === 0) {
    rssSection.innerHTML = '<p>No posts available from monitored tags</p>';
    return;
  }

  // Create a container for the feed structure
  const feedContainer = document.createElement('div');
  feedContainer.className = 'feed-container';
  
  // Add a counter that stays fixed at the top
  const counterDiv = document.createElement('div');
  counterDiv.className = 'feed-counter';
  
  // Create a scrollable container for posts
  const postsContainer = document.createElement('div');
  postsContainer.className = 'posts-scroll-container';
  
  // Limit the number of posts according to user settings
  const visiblePosts = posts.slice(0, settings.maxPosts);
  
  // Update counter text
  counterDiv.innerHTML = `<strong>${visiblePosts.length}</strong> of ${posts.length} posts from monitored tags`;
  
  // Add posts to the scrollable container
  visiblePosts.forEach((post) => {
    const postDiv = document.createElement('div');
    postDiv.className = 'rss-post';
    
    // Parse the description to extract content and media
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = post.description;
    
    // Extract author information from guid or link
    let author = post.creator || "";
    
    // For Mastodon, try to extract username from the link
    if (!author && post.link) {
      const linkParts = post.link.split('@');
      if (linkParts.length > 1) {
        author = linkParts[1].split('/')[0];
      }
    }
    
    // If title contains a username format (username: content), extract it
    if (!author && post.title && post.title.includes(":")) {
      const parts = post.title.split(":", 2);
      author = parts[0].trim();
    }
    
    // Get the content from description, not just the title
    // Process description content for display
    const contentLinks = tempDiv.querySelectorAll('a');
    // Ensure links open in new tabs
    contentLinks.forEach(link => {
      link.setAttribute('target', '_blank');
      // Preserve hashtags as clickable links
      if (link.classList.contains('mention') && link.classList.contains('hashtag')) {
        link.style.textDecoration = 'none';
        link.style.fontWeight = 'bold';
        link.style.color = '#2b90d9';
      }
    });
    
    // Check for images in the description
    const images = tempDiv.querySelectorAll('img');
    
    // Combine explicitly defined media and images from description
    let mediaHtml = '';
    
    // Add images from description
    if (images.length > 0) {
      mediaHtml = Array.from(images).map(img => 
        `<div class="post-media">
          <img src="${img.src}" alt="${img.alt || 'Post image'}" loading="lazy">
        </div>`
      ).join('');
    }
    
    // Add media from enclosures if any
    if (post.media && post.media.length > 0) {
      post.media.forEach(item => {
        if (item.type && item.type.startsWith('image/')) {
          mediaHtml += `
            <div class="post-media">
              <img src="${item.url}" alt="Media attachment" loading="lazy">
            </div>
          `;
        } else if (item.type && item.type.startsWith('video/')) {
          mediaHtml += `
            <div class="post-media">
              <video controls src="${item.url}" preload="none" class="media-video">
                Your browser does not support the video tag.
              </video>
            </div>
          `;
        } else if (item.url) {
          // For other media types, just add a link
          mediaHtml += `
            <div class="post-media">
              <a href="${item.url}" target="_blank" class="media-attachment">
                Attached media
              </a>
            </div>
          `;
        }
      });
    }
    
    // Create tag list HTML
    let tagsHtml = '';
    if (post.allTags && post.allTags.length > 0) {
      // Show all tags, highlight the monitored ones
      tagsHtml = '<div class="post-tags">';
      post.allTags.forEach(tag => {
        const isMonitored = userTags.includes(tag.toLowerCase());
        tagsHtml += `<a href="https://${settings.mastodonInstance}/tags/${tag}" 
                      target="_blank" 
                      class="tag-link ${isMonitored ? 'monitored-tag' : ''}"
                      title="${isMonitored ? 'Monitored tag' : 'Click to view tag feed'}"
                      >#${tag}</a> `;
      });
      tagsHtml += '</div>';
    }
    
    // Build the post HTML
    postDiv.innerHTML = `
      <div class="post-header">
        <div class="post-author">${author}</div>
        <a href="${post.link}" class="view-original" target="_blank" title="View original post">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
            <polyline points="15 3 21 3 21 9"></polyline>
            <line x1="10" y1="14" x2="21" y2="3"></line>
          </svg>
        </a>
      </div>
      <div class="post-content">
        <div class="content-text">${tempDiv.innerHTML}</div>
        ${mediaHtml}
      </div>
      <div class="post-meta">
        <small class="post-date">${post.pubDate.toLocaleString()}</small>
        <small class="tag-source">Via: <a href="https://${settings.mastodonInstance}/tags/${post.tag}" target="_blank">#${post.tag}</a></small>
      </div>
      ${tagsHtml}
    `;

    postsContainer.appendChild(postDiv);
  });
  
  // Assemble the components in the right order
  feedContainer.appendChild(counterDiv);
  feedContainer.appendChild(postsContainer);
  rssSection.appendChild(feedContainer);
}
       
      // Fetch trending hashtags from Mastodon
function fetchMastodonTags() {
  const trendsSection = $('#mastodon-trends-section');
  trendsSection.innerHTML = '<p>Loading trending tags...</p>';

  fetch(`https://${settings.mastodonInstance}/api/v1/trends/tags`)
    .then(response => {
      if (!response.ok) throw new Error(`HTTP error ${response.status}`);
      return response.json();
    })
    .then(data => {
      const topFiveTags = data.slice(0, 5);
      
      if (topFiveTags.length === 0) {
        trendsSection.innerHTML = '<p>No trending tags available</p>';
        return;
      }

      // Create a table for better layout
      const table = document.createElement('table');
      table.className = 'trending-tags-table';
      
      // Create header row
      const headerRow = document.createElement('tr');
      const tagHeader = document.createElement('th');
      tagHeader.textContent = 'Trending Tag';
      const actionsHeader = document.createElement('th');
      actionsHeader.textContent = 'Actions';
      headerRow.appendChild(tagHeader);
      headerRow.appendChild(actionsHeader);
      table.appendChild(headerRow);
      
      topFiveTags.forEach(tag => {
        const row = document.createElement('tr');
        
        // Tag name cell
        const tagCell = document.createElement('td');
        const tagLink = document.createElement('a');
        tagLink.href = tag.url;
        tagLink.target = '_blank';
        tagLink.className = 'trending-tag-link';
        tagLink.textContent = `#${tag.name}`;
        tagCell.appendChild(tagLink);
        
        // Actions cell
        const actionsCell = document.createElement('td');
        
        // Check if tag is already monitored
        const isMonitored = userTags.includes(tag.name.toLowerCase());
        
        if (isMonitored) {
          // Show that it's already monitored
          const monitoredBadge = document.createElement('span');
          monitoredBadge.className = 'monitored-badge';
          monitoredBadge.innerHTML = '✓ Monitored';
          actionsCell.appendChild(monitoredBadge);
        } else {
          // Add button to monitor the tag
          const addButton = document.createElement('button');
          addButton.className = 'add-tag-button';
          addButton.textContent = 'Monitor';
          addButton.addEventListener('click', () => {
            if (addTag(tag.name)) {
              displayCurrentTags();
              fetchRSSFeeds();
              // Refresh this display to update buttons
              fetchMastodonTags();
            }
          });
          actionsCell.appendChild(addButton);
        }
        
        // Add cells to the row
        row.appendChild(tagCell);
        row.appendChild(actionsCell);
        
        // Add row to the table
        table.appendChild(row);
      });

      trendsSection.innerHTML = '';
      trendsSection.appendChild(table);
    })
    .catch(error => {
      console.error('Error fetching trending tags:', error);
      trendsSection.innerHTML = `<div class="error">Error loading trending tags: ${error.message}</div>`;
    });
}
       
      // Clock for the header
  function updateDateTime() {
  const now = new Date();
  let dateTimeString;
  
  if (settings.timezone === 'local') {
    // Use local system time
    dateTimeString = now.toLocaleDateString() + ' ' + now.toLocaleTimeString();
  } else {
    // Use specified time zone
    const options = {
      timeZone: settings.timezone,
      year: 'numeric',
      month: 'numeric',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      second: 'numeric',
      hour12: true
    };
    
    try {
      dateTimeString = now.toLocaleString('en-US', options);
      
      // Add time zone abbreviation if not using local time
      const timeZoneAbbr = getTimeZoneAbbreviation(settings.timezone);
      if (timeZoneAbbr) {
        dateTimeString += ` (${timeZoneAbbr})`;
      }
    } catch (error) {
      console.error('Error formatting date with timezone:', error);
      // Fallback to local time
      dateTimeString = now.toLocaleDateString() + ' ' + now.toLocaleTimeString();
    }
  }
  
  $('#date-time').textContent = dateTimeString;
}

// Helper function to get time zone abbreviation
function getTimeZoneAbbreviation(timezone) {
  const abbreviations = {
    'America/New_York': 'ET',
    'America/Chicago': 'CT',
    'America/Denver': 'MT',
    'America/Los_Angeles': 'PT',
    'America/Anchorage': 'AKT',
    'Pacific/Honolulu': 'HT',
    'Europe/London': 'GMT/BST',
    'Europe/Paris': 'CET',
    'Europe/Moscow': 'MSK',
    'Asia/Tokyo': 'JST',
    'Asia/Shanghai': 'CST',
    'Australia/Sydney': 'AEST'
  };
  
  return abbreviations[timezone] || '';
}
      
      // --------- Intervals ---------
      
      // Store interval IDs so we can clear and reset them
      let intervals = {
        dateTime: null,
        trendingTags: null,
        trendingLinks: null,
        tagMonitors: null,
        news: null
      };
      
      // Function to reset all intervals (called when settings change)
      function resetIntervals() {
        // Clear existing intervals
        Object.values(intervals).forEach(interval => {
          if (interval) clearInterval(interval);
        });
        
        // Set new intervals based on current settings
        intervals.dateTime = setInterval(updateDateTime, 1000);
        intervals.trendingTags = setInterval(fetchMastodonTags, settings.refreshIntervals.trendingTags * 60 * 1000);
        intervals.trendingLinks = setInterval(fetchMastodonTrends, settings.refreshIntervals.trendingLinks * 60 * 1000);
        intervals.tagMonitors = setInterval(fetchRSSFeeds, settings.refreshIntervals.tagMonitors * 60 * 1000);
        intervals.news = setInterval(fetchNewsFeed, settings.refreshIntervals.news * 60 * 1000);
      }
      
      // --------- Initialization ---------
      
      // Initialize the application
      function init() {
        // Update settings UI
        updateSettingsUI();
        
        // Initialize tag display
        displayCurrentTags();
        
        // First-time data fetching
        updateDateTime();
        fetchMastodonTags();
        fetchMastodonTrends();
        fetchRSSFeeds();
        fetchNewsFeed();
        
        // Set up refresh intervals
        resetIntervals();

         // Add event listener for tag changes
  document.addEventListener('tagListChanged', function(e) {
    // Refresh the tag displays
    displayCurrentTags();
    fetchMastodonTags();
  });

      }
      
      // Start the application
      init();
    </script>
  </body>
</html>
